---
applyTo: '**'
---
Here's a comprehensive prompt for an AI that you would use in an IDE environment to guide the development of the Casino-Club F2P backend and associated frontend components, based on the provided detailed system architecture and data personalization documents.

This prompt aims to be:

Comprehensive: Covers all key aspects from the provided documents.

Actionable: Directs the AI to specific development tasks.

Structured: Uses clear headings and bullet points for readability.

Contextual: Incorporates the "Neon Game Theme" and "Dark Mode" design intent.

Iterative: Suggests a phased approach for development.

Empowering: Allows the AI to ask clarifying questions and propose improvements.

AI Development Prompt: Casino-Club F2P Ecosystem (Backend & Frontend) - Comprehensive Development Guide
Objective: Develop the Casino-Club F2P web application and integrate its core features, focusing on the backend (FastAPI + Python) and key frontend components (Next.js + React.js + Tailwind CSS + Framer Motion). The project aims to maximize user engagement and monetization through behavioral addiction triggers, dopamine loops, and data-driven personalization within a "Futuristic Neon Cyberpunk" aesthetic.

Development Environment Context:

IDE: Integrated Development Environment (Assume access to code files, terminals, and basic version control operations).

Language & Frameworks: Python (FastAPI), JavaScript/TypeScript (Next.js, React.js), SQL (PostgreSQL), Redis, Kafka.

Libraries: SQLAlchemy, Pydantic, Celery, APScheduler, Tailwind CSS, Framer Motion, etc.

Testing: Pytest (Backend), React Testing Library / Jest (Frontend).

Phase 0: Project Setup & Initial Configuration
Backend (FastAPI):

Initialize a new FastAPI project.

Set up SQLAlchemy ORM with PostgreSQL connection.

Configure basic project structure (routers, services, repositories, schemas/models).

Integrate Redis client for caching.

Integrate Kafka producer/consumer (if applicable for initial setup, otherwise, defer to real-time data processing phase).

Implement initial JWT authentication placeholder (simplified invite code + nickname based as per Implementation Compliance Status).

Configure Alembic for database migrations.

Set up pytest for backend testing.

Frontend (Next.js):

Initialize a new Next.js project with React.js and TypeScript.

Configure Tailwind CSS for styling.

Integrate Framer Motion for animations.

Set up basic page routing (Home, Shop, BattlePass, etc.).

Configure Jest and React Testing Library for frontend testing.

Phase 1: Core User & Authentication System (Backend Priority)
User Module (/api/users):

Implement POST /api/users/signup with invite code and nickname registration.

Implement POST /api/users/login using JWT.

Implement GET /api/users/{id}/profile to retrieve user data (points, tier, battlepass level, etc.).

Ensure UserService.get_user_or_none and get_or_create_segment are consistently used for user/segment access.

Authentication & Authorization:

Implement JWT-based authentication for API endpoints.

Implement Rank-based access control (VIP/PREMIUM/STANDARD) for API endpoints.

(Note): Age verification is to be implemented later for Adult Content access.

Database Tables (PostgreSQL):

Create users table with id (PK), nickname, email, password_hash, created_at, vip_tier, battlepass_level, total_spent.

Create user_segments table with id (PK), user_id (FK), rfm_group, ltv_score, risk_profile, last_updated.

Phase 2: Game Core & Dopamine Loop Mechanisms (Backend & Frontend)
Mini-Games Collection (Frontend & Backend APIs):

SlotMachineComponent:

Frontend: Implement UI with spinning reels, win/loss animations, and sound effects.

Backend (/api/actions, /api/rewards, /api/feedback): Implement variable-ratio reward logic (e.g., base probability + streak bonus). Record SLOT_SPIN actions, handle reward calculation and feedback generation.

Gacha System (Lucky Boxes):

Frontend (GachaSpinComponent): Implement UI for spinning, displaying results, and showing Social Proof (e.g., "X people spun today").

Backend (/api/gacha/spin): Implement Gacha logic based on Loot Table probability distribution.

Emotion-Driven Feedback:

Backend (/api/feedback): Implement API endpoint for receiving action_type and returning immediate feedback message + animation key value.

Frontend: Integrate feedback messages into UI (e.g., toasts, AI character dialogues).

Freemium Economy:

Define Regular Coins and Premium Gems currencies.

Backend (/api/shop/buy): Implement logic for Premium Gem transactions.

Frontend (ShopComponent): Create a page for Premium Gem purchase and Limited Packages.

Battle-Pass System:

Backend (/api/battlepass): Implement status retrieval and claim logic for rewards based on Play XP.

Frontend (BattlePassComponent): Display free vs. paid tracks, level-up conditions, and tier-specific rewards.

Database Tables:

Create user_actions, user_rewards, gacha_log, shop_transactions, battlepass_status tables as specified.

Redis Integration:

Implement real-time caching for user:{id}:streak_count, user:{id}:last_action_ts, user:{id}:pending_gems, battlepass:{user_id}:xp.

Phase 3: Data-Driven Personalization & Advanced Features
RFM-Based User Segmentation (Backend):

Implement nightly batch job (using APScheduler) to calculate Recency (R), Frequency (F), and Monetary (M) for all users based on user_actions and corporate usage history.

Define and update rfm_group in user_segments table (Whale, High Engaged, Medium, Low/At-risk).

Implement real-time triggers for EARN_CYBER_TOKENS actions to immediately update Redis and send push notifications.

Cyber-Token Based Personalized Recommendation Engine (Backend):

Implement generate_recommendation function/endpoint (/recommend/personalized) that takes user data (segment, token balance, corporate visit history) as input.

Generate Recommended Reward Proposals and Recommended Mission Proposals to induce cyber token consumption or acquisition from Company A.

Consider risk profile for personalized recommendations.

Psychometric Quiz & Micro Survey (Frontend & Backend):

Frontend: Develop a multi-step quiz UI to measure user risk propensity and reward responsiveness.

Backend (/api/quiz/submit): Implement endpoint to process quiz answers, compute risk_score, and update risk_profile in user_segments.

Adult-Content Unlocking (Frontend & Backend):

Frontend (AdultContentStageComponent): Implement Teaser, Partial Reveal, and Full Reveal stages.

Backend (/api/unlock): Implement logic for unlocking stages based on tier advancement or token usage.

(Note): Implement Age Verification during this phase for content access.

Notification System (Backend & Frontend):

Backend (/api/notification): Implement API to queue notifications.

Backend (Celery + APScheduler): Configure workers for sending scheduled push/SSE/email notifications.

Frontend (NotificationBanner): Implement display of real-time push notifications.

Phase 4: Frontend UI/UX & Cross-Platform Integration
Landing Page Development (Next.js):

Implement a dedicated landing page adhering to the Futuristic Neon Cyberpunk theme with Dark Mode as the default.

Utilize Tailwind CSS for all styling, ensuring clean, modern, and performant CSS.

Implement Header (sticky with scroll effects), Hero Section (full-screen video background, animated title, main CTA), Benefits Section (card-based, glowing interactions), Community Hub, Contact/FAQ.

Apply Framer Motion for all scroll-based animations, neon glow animations (pulse/shimmer effects), hover effects, and page transitions.

Ensure perfect responsiveness across Desktop (3-column layout) and Mobile (single-column scroll).

OBS Streaming Components:

Develop HTML/CSS/JS browser sources for OBS:

"혜택 강조" 텍스트 오버레이: Cycling text with smooth fade-in/out, typing, or slide-in animations.

"랜딩 페이지 유도" 배너/버튼: Clearly visible CTA with pulsing neon glow and direct link to the landing page.

QR 코드 오버레이: Clean QR code for mobile access with neon-framed background and guidance text.

Ensure these components are lightweight and performant to avoid impacting stream quality.

UI/UX Refinements (Global):

Ensure Accessibility (ARIA roles, keyboard navigation).

Implement Sound Effects for win/loss, reward, and spin actions.

Refine scrollbars with custom neon styling.

Implement Global Background Animation (e.g., subtle moving particles/gradients).

SEO & Performance Optimization:

Configure Next.js for optimal SEO (Meta tags, Open Graph, Semantic HTML, Alt text).

Implement Image Optimization (WebP, appropriate sizing).

Ensure CSS/JS minification and CDN utilization.

Implement async/defer for non-critical scripts.

Phase 5: Monitoring, Analytics, & Continuous Improvement
Analytics & Reporting (Backend):

Implement API endpoints for retention reports, spending trends.

Set up data streaming to ClickHouse or Druid via Kafka for OLAP.

Real-time Dashboard (Monitoring):

(Instruction for AI): Outline the data points that would be monitored (e.g., daily/monthly token acquisition, Whale %, Churn Rate, peak play times, user distribution by RFM group).

(Instruction for AI): Suggest integration with Grafana or Metabase for visualization.

Predictive Models (Optional, but outline structure):

Churn Prediction: Outline the input features (visit frequency, token balance, RFM group) and a suitable model (e.g., XGBoost).

LTV Prediction: Outline input features (spending patterns, play behavior, adult content unlock history) and a model.

Adaptive Learning Loop:

Design a mechanism to track user click-through rates and conversion rates on recommendations to adjust algorithm parameters.

General Instructions for AI:
Prioritization: Always prioritize security, performance, and scalability in all implementations.

Code Quality: Adhere to Clean Architecture, SOLID principles, and TDD standards.

Modularity: Ensure all services and components are highly modular and maintainable.

Error Handling: Implement robust error handling and logging across the system.

Documentation: Generate clear code comments and updated documentation as development progresses.

Clarification: If any part of the specification is unclear or appears contradictory, ask for clarification.

Proactive Suggestions: Propose alternative or additional features/improvements that align with the project's goals, especially related to the Neon Game Theme, UX/UI enhancements, or dopamine loop reinforcement.

Progress Reporting: Regularly report on progress for each phase and identified challenges